#' Main popEye encoding function 
#' 
#' This function is used when you want to analyze eye tracking data using popEye.
#' 
#' @param datpath Path to eye tracking files
#' @param tracker.model Eye tracker used for data collection (only "eyelink"
#' available at present)
#' @param tracker.software Software used for data collection ("EB" for 
#' "Experiment Builder" or "ET" for "EyeTrack")
#' @param tracker.results Whether a results file is generated by the eye tracking
#' software (TRUE or FALSE)
#' @param type Type of experiment used in the study ("sentence", "target", 
#' "boundary", "fast")
#' @param message.start Message in eye tracking file indicating the start of
#' the trial
#' @param message.stop Message in eye tracking file indicating the end of the trial
#' @param message.boundary Message in eye tracking file indicating when the boundary
#' is triggered (only relevant for boundary and fast priming experiments)
#' @param message.target Message in eye tracking file indicating the onset of
#' the target display (only relevant for boundary experiments)
#' @param message.prime Message in eye tracking file indicating the onset of the
#' prime display (only relevant for fast priming experiments)
#' @param variable.id Variable in eye tracking experiment indicating which item 
#' is displayed in a trial ("id" by default)
#' @param variable.cond Variable in eye tracking experiment indicating in which
#' (within-item) condition the item is displayed in a trial (if any; no
#' conditions by default)
#' @param item.practice Indicator for a practice item that is displayed at the 
#' beginning of an experiment (only relevant for EyeTrack experiments)
#' @param item.trigger Indicator for an gaze trigger element used in the 
#' experiment (only relevant for EyeTrack experiments) 
#' @param item.question Indicator for a comprehension question trial used  
#' during the experiment (only relevant for EyeTrack experiments)
#' @param item.pracnum Number of practice items shown at the beginning of an
#' experiment (which are discarded during the analysis)
#' @param stimulus.file Path and name of stimulus file
#' @param stimulus.id Name of the column providing the item number 
#' in stimulus file
#' @param stimulus.cond Name of the column providing the condition name in the
#' stimulus file
#' @param stimulus.preview Name of the column providing the preview display
#' in the stimulus file (only relevant for boundary and fast priming exeriments)
#' @param stimulus.prime Name of the column providing the prime display in the 
#' stimulus file (only relevant for fast priming experiments)
#' @param stimulus.text Name of the column providing the target (or only) display
#' in the stimulus file 
#' @param indicator.word Indicator used to separate words from each other
#' (blank by default)
#' @param indicator.ia Indicator used to separate interest areas from each other
#' ("ยง" by default)
#' @param indicator.target Indicator used to denote the target interest area 
#' ("*" by default)
#' @param indicator.line Indicator used for manual line breaks ("\\n" by default)
#' @param display.marginLeft Size of the margin at the left of the screen
#' (in pixels)
#' @param display.marginTop Size of the margin at the top of the screen (in pixels)
#' @param display.marginRight Size of the margin at the right of the screen 
#' (in pixels)
#' @param display.marginBottom Size of the margin at the bottom of the screen
#' (in pixels)
#' @param font.name Name of the font used in the experiment (currently, "CourierNew",
#' "Consolas", and "Symbol" are supported)
#' @param font.size Size of the font (in pixels)
#' @param font.spacing Spacing between lines (1, 1.5, or 2)
#' @param analysis.eyelink Should the real-time parsing from the eyelink system 
#' be used? (TRUE or FALSE, default is TRUE)
#' @param analysis.vfac Velocity threshold used for saccade detection (see Engbert & Kliegl, 
#' 2003; default is 5)
#' @param analysis.mindur Minimum duration of a saccade (see Engbert & Kliegl, 2003; 
#' default is 10 ms)
#' @param analysis.postdur Minimum duration of a fixation (see Engbert & Kliegl, 
#' 2003; default is 30 ms)
#' @param analysis.drift Treat fixations with drift in x or y dimension as blinks
#' (TRUE or FALSE; default is TRUE. See Engbert & Kliegl, 2003)
#' @param analysis.sparse If TRUE, the msg, sample, and event slots are cleaned
#' during the analysis (TRUE or FALSE, default is TRUE)
#' @param analysis.driftX If TRUE fixation is corrected for drift on the x
#' axis (TRUE or FALSE, default is FALSE; only relevant for EB experiments in
#' which the drift correct element is used) 
#' @param analysis.driftY If TRUE fixation is corrected for drift on the y
#' axis (TRUE or FALSE, default is FALSE; only relevant for EB experiments in
#' which the drift correct element is used)
#' @param analysis.translate If TRUE fixations are moved to fit into text area
#'(TRUE or FALSE, default is FALSE)
#' @param analysis.lineMethod Method used to assign fixations to lines ("attach",
#' "chain" or "merge", "chain" is default; see Vignette)
#' @param analysis.outlierX Parameter for outlier detection on the x axis 
#' (number of line heights a fixation is allowed to deviate from last letter 
#' on a line; default is 2)
#' @param analysis.outlierY Parameter for outlier detection on the y axis
#' (number of line heights a fixation is allowed to deviate from the first or
#' last line on a screen, default is 2)
#' @param analysis.lineX Parameter used to detect runs on the x axsis 
#' if "chain" method is used (default is 20)
#' @param analysis.lineY Parameter used to detect runs on the y axsis 
#' if "chain" method is used (default is 2)
#' @param clean.stage1Dur Minimum duration for fixation during stage 1 
#' cleaning (default: 80 ms)
#' @param clean.stage1Dist Minimum distance between fixations (in number
#' of letters) during stage 1 cleaning (default: 1)
#' @param clean.stage2Dur Minimum duration of fixation during stage 2
#' cleaning (default: 40 ms)
#' @param clean.stage2Dist Minimum distance between fixations (in number
#' of letters) during stage 2 cleaning
#' @param clean.stage3 If TRUE, stage 3 cleaning is conducted (default is FALSE)
#' @param clean.stage3Dur Minimum duration of fixation during stage 3 cleaning 
#' (default is 140 ms)
#' @param clean.stage4 If TRUE stage 4 cleaning is conducted (default is FALSE)
#' @param clean.stage4Min Minimum duration of fixation during stage 4 cleaning
#' (default is 80 ms)
#' @param clean.stage4Max Maximum duration of fixation during stage 4 cleaning
#' (default is 800 ms)
#' @param clean.outlier If TRUE outlying fixations at the begining and the end
#' of a trial are deleted (default is FALSE)
#' @param exclude.blink If TRUE a trial is flagged as critical if at least one
#' blink has occured on it (default is FALSE)
#' @param exclude.nfix Minimum number of fixations that a trial has to have 
#' received (deleted otherwise; default is 3)
#' @param exclude.sac Duration for screen for unplausibel long saccades (in ms;
#' 200 ms as default).
#' @param outpath Path were output file should be saved
#' @param outname Name of output file
#' @param select.version Restrict analysis to a specific version of the experiment
#' (numeric; internal for debugging; only relevant for EB experiments)
#' @param select.subject Restrict analysis to a specific subject (within a version)
#' (numeric; internal for debugging). Select a single subject by specifying a single
#' number (e.g., select.subject = 4). Select a range of subjects by using the colon 
#' operator (e.g., select.subject = 1:4).
#' @param select.trial Restrict analysis to a specific trial (numeric; internal for debugging)
#' @param debug Perform analysis only for specific steps of the analysis ("setup", 
#' "read", "remove", "create")

popEye <- function(datpath, 
                   stimulus.file,
                   # NOTE: maybe change name to stimfile
                   tracker.model = "eyelink", 
                   tracker.software = "EB", 
                   tracker.results = FALSE,
                   type = "sentence", 
                   message.start = "SYNCTIME", 
                   message.stop = "stop",
                   message.boundary = "boundary", 
                   message.target = "target",
                   message.prime = "prime", 
                   variable.id = "id", 
                   variable.cond = NA,
                   # NOTE: maybe change to missing in functions
                   item.practice = "^P", 
                   item.trigger = "999",
                   item.question = 1000, 
                   item.pracnum = 0,
                   stimulus.id = "id",
                   stimulus.cond = NA, 
                   # NOTE: maybe change to missing in functions
                   stimulus.preview = "preview",
                   stimulus.prime = "prime", 
                   stimulus.text = "text", 
                   indicator.word = " ", 
                   indicator.ia = " ", 
                   indicator.target = "\\*", 
                   indicator.line = "\\\\n",
                   display.marginLeft = 150, 
                   display.marginTop = 300, 
                   display.marginRight = 50, 
                   display.marginBottom = 100, 
                   font.name = "CourierNew", 
                   font.size = 16, 
                   font.spacing = 2,
                   analysis.eyelink = TRUE, 
                   analysis.vfac = 5, 
                   analysis.mindur = 10, 
                   analysis.postdur = 30,
                   analysis.drift = TRUE, 
                   analysis.sparse = TRUE,
                   analysis.driftX = FALSE, 
                   analysis.driftY = FALSE,
                   analysis.translate = FALSE,
                   analysis.lineMethod = "chain",
                   analysis.outlierX = 100,
                   analysis.outlierY = 100,
                   analysis.lineX = 20,
                   analysis.lineY = 0.5,
                   clean.stage1Dur = 80, 
                   clean.stage1Dist = 1,
                   clean.stage2Dur = 40, 
                   clean.stage2Dist = 3,
                   clean.stage3 = FALSE, 
                   clean.stage3Dur = 140, 
                   clean.stage4 = FALSE, 
                   clean.stage4Min = 80,
                   clean.stage4Max = 800, 
                   clean.delete = FALSE,
                   clean.outlier = FALSE,
                   exclude.nfix = 3, 
                   exclude.sac = 150,
                   outpath = getwd(), 
                   outname = "",
                   # NOTE: Maybe combine outpath and outname to one parameter
                   select.version = NULL,
                   select.subject = NULL,
                   select.trial = NULL,
                   debug = "none"
                   
) {
  
  
  # ----------------------------------
  # setup experiment 
  # ----------------------------------
  
  message("Initialize experiment")
  
  # create output file
  exp <- list(setup = NA, subjects = list())
  
  # retrieve setup infomation
  exp$setup <- SetupExperiment()
  
  # create output files
  CreateOutput()
  
  if (debug == "setup") {
    return (exp)
  }
  
  
  # create version list
  # --------------------
  
  # check for version
  if (tracker.software == "EB") {
    if (length(grep("results", list.files(datpath))) == 0) {
      version.list <- list.files(datpath)
      version.list <- paste("/", version.list, "/", sep = "") # here ?
    } else {
      version.list <- ""
    }  
  } else if (tracker.software == "ET") {
    version.list <- ""
  }
  
  # initialize number of subjects
  nsub <- 0
  
  
  # ----------------------------------
  # version loop
  # ----------------------------------
  
  if (missing(select.version) == T) {
    version.arg1 <- 1
    version.arg2 <- length(version.list)
  } else {
    version.arg1 <- select.version
    version.arg2 <- select.version
  }
  
  for (v in version.arg1:version.arg2) {
    
    # v <- 2
    
    if ((version.arg2 - version.arg1) > 0) {
      message(paste("Version ", v, sep = ""))
    }
    
    # list of subjects
    if (tracker.software == "EB") {
      filepath <- paste(datpath, version.list[v], "results/", sep = "")  
      sub.list <- list.files(filepath)
    } else if (tracker.software == "ET") {
      filepath <- paste(datpath, version.list[v], sep = "")  
      sub.list <- list.files(filepath)
      sub.list <- sub.list[grep("asc", sub.list)]
    }
    
    # select subjects
    if (missing(select.subject) == F) {
      sub.list <- sub.list[is.element(sub.list, select.subject)]
    }
    
    if (debug == "participants") {
      return (sub.list)
    }
    
    
    # ----------------------------------
    # subject loop
    # ----------------------------------
    
    subject.arg1 <- 1
    subject.arg2 <- length(sub.list)
    
    for (s in subject.arg1:subject.arg2) {
      
      # increment number of subjects
      nsub <- nsub + 1

      # generate header slot
      header <- list()
      
      subid <- gsub("\\.asc", "", sub.list[s])
      header$subid <- subid
      header$version <- v
      
      # message subject
      message(paste(". Subject ", s, ": ", subid, sep = ""))
      
      # TODO: store other information about subject (e.g., version)
      
      
      # --------------------------------------------
      # Modul 1: Preprocessing
      # --------------------------------------------
      
      # message(". Modul 1: Preprocessing")
      
      
      # read data
      # -----------
      
      message(".. Read data")
      dat <-  ReadData(filepath, subid)
      # TODO: read in edf directly (-> external packages)
      # TODO: asc data processing rather slow
      
      if (debug == "read") {
        return (dat)
      }
      
      # remove data
      # --------------
      
      message(".. Remove data")
      
      dat <- RemoveData(dat) 
      
      if (debug == "remove") {
        return (dat)
      }
      
      
      # create trials
      # ---------------
      
      message(".. Create trials")
     
      dat <- CreateTrials(dat)
      
      if (debug == "create") {
        return (dat)
      }
      
      
      # -----------------------
      # Modul 2: Cleaning
      # -----------------------
      
      # message(". Modul 2: Cleaning")
      
      # add stimulus information
      # -------------------------
      
      message(".. Add stimulus")
      
      dat <- ReadStimulus(dat)
      
      if (debug == "add") {
        return (dat)
      }
      
      
      # extract fixations
      # --------------------
      
      message(".. Extract fixations")
      
      dat <- ExtractFixation(dat)
      
      if (debug == "extract") {
        return (dat)
      }
      
      
      # assign letters/words
      # ---------------------
      
      message(".. Assign stimulus")
      
      dat <- MatchStim(dat)
      
      if (debug == "assign") {
        return (dat)
      }
      
      
      # clean IAs
      # -----------
      
      message(".. Cleaning interest area")
      
      dat <- CleanIA(dat)
      
      # NOTE: not sure whether this should be implemented here (or at all)
      # NOTE: stage3 cleaning is completely useless !
      # NOTE: stage4 cleaning is dangerous !
      # TODO: report deleted fixations
      
      
      # compute fixation measures
      # --------------------------
      
      message(".. Compute fixation measures")
      
      dat <- ComputeFixationMeasures(dat)
      
      
      # retrieve saccades and blinks
      # -----------------------------
      
      message(".. Compute saccade measures")
      
      dat <- ProcessSaccades(dat)
      
      
      # combine events
      # ----------------
      
      message(".. Combine events")
      
      dat <- CombineEvents(dat)
      
      
      # cleaning
      # ---------
      
      message(".. Cleaning trial")
      
      dat <- CleanAll(dat)
      # NOTE: think about relationship between cleaning here and in main analysis
      
      
      # clean trials
      # -------------
      
      if (exp$setup$analysis$sparse == TRUE) {
        dat <- Sparse(dat)
      }
      
      
      # finalize
      # ---------
      
      # names for trial slots
      for (i in 1:length(dat$trial)) {
        
        names(dat$trial)[i] <- paste("trial", i, sep = ".")
        # NOTE: select by trialid or itemid?
        
        dat$trial[[i]]$fix$trialid <- i
        dat$trial[[i]]$sac$trialid <- i
        dat$trial[[i]]$meta$stimmat$trialid <- i
        
        fix <- rbind(fix, dat$trial[[i]]$fix)
        sac <- rbind(sac, dat$trial[[i]]$sac)
        
      }
      
      # save in experiment slot
      exp$subjects[[nsub]] <- list(header = header, trials = dat$trial)
      
      # names for participant slot
      names(exp$subjects)[nsub] <- paste("Participant", subid, sep = ".")
      
      
      # -----------------------
      # Modul 3: Aggregation
      # -----------------------
      
      # message(". Modul 3: Aggregation")
      
      # item file
      # -----------
      
      message(".. Load item file")
      
      word.itemtmp <- ItemFileWord(dat)
      word.item <- rbind(word.item, word.itemtmp)
      
      ia.itemtmp <- ItemFileIA(dat)
      ia.item <- rbind(ia.item, ia.itemtmp)
      
      sent.itemtmp <- ItemFileSent(dat)
      sent.item <- rbind(sent.item, sent.itemtmp)
      
      
      # results file
      # -------------
      
      # TODO: integration results file and experiment needs to be improved
      
      if (exp$setup$tracker$software == "EB" & exp$setup$tracker$results == T) {
        
        message(".. Load results file")
        
        resultstmp <- ResultsFile(subid,
                                  filepath)
        resultstmp$text$subid <-  subid
        resultstmp$quest$subid <-  subid
        results <- list(text = rbind(results$text, resultstmp$text),
                        quest = rbind(results$quest, resultstmp$quest))
      }
      
      
      # clean file
      # -------------
      
      message(".. Create clean file")
      
      cleantmp <- CreateClean(dat)
      cleantmp$subid <- subid
      clean <- rbind(clean, cleantmp)
      
    }
    
  }
  
  # NOTE: save number of subjects in setup slot?
  
  
  # collect output files
  # ---------------------
  
  exp$out$word.item <- word.item[-1, ]
  row.names(exp$out$word.item) <- NULL
  
  exp$out$ia.item <- ia.item[-1, ]
  row.names(exp$out$ia.item) <- NULL
  
  exp$out$sent.item <- sent.item[-1, ]
  row.names(exp$out$sent.item) <- NULL
  
  exp$out$fix <- fix
  row.names(exp$out$fix) <- NULL
  
  exp$out$sac <- sac
  row.names(exp$out$sac) <- NULL
  
  # results
  if (exp$setup$tracker$software == "EB" & exp$setup$tracker$results == T) {
    exp$out$results$text <- results$text[-1, ]
    row.names(exp$out$results$text) <- NULL
    exp$out$results$quest <- results$quest[-1, ]
    row.names(exp$out$results$quest) <- NULL
  }
  
  exp$out$clean <- clean[-1, ]
  row.names(exp$out$clean) <- NULL
  
  if (debug == "aggregate") {
    return (exp)
  }
  
  
  # aggregate words
  # ----------------
  
  message("Aggregate words")
  
  exp$out$wordfirst <- AggregateWordsFirstrun(exp)
  exp$out$wordtmp <- AggregateWords(exp)
  exp <- CombineWords(exp)
  
  
  # aggregate IAs
  # --------------
  
  message("Aggregate IAs")
  
  exp$out$iafirst <- AggregateIAsFirstrun(exp)
  exp$out$iatmp <- AggregateIAs(exp)
  exp <- CombineIAs(exp)
  
  
  # aggregate sentences
  # --------------------
  
  message("Aggregate sentences")
  
  exp$out$sentfirst <- AggregateSentencesFirstrun(exp)
  exp$out$senttmp <- AggregateSentences(exp)
  exp <- CombineSentences(exp)
  
  
  # aggregate trials
  # -----------------
  
  message("Aggregate trials")
  
  exp <- AggregateTrials(exp)
  
  
  # aggregate participants
  # ------------------
  
  message("Aggregate participants")
  
  exp <- AggregateSubjects(exp)
  
  
  # clean up
  # ----------
  
  # exp$out$ia.item <- NULL
  # exp$out$word.item <- NULL
  # exp$out$sent.item <- NULL
  
  
  # save
  # -----
  
  message("Save")
  
  # set outpath
  if (outpath == "") {
    outpath <- getwd()
  }

  # set outname
  if (outname == "") {
    tmp <- unlist(strsplit(datpath, "/"))
    outname <- tmp[length(tmp)]
  }

  # save
  saveRDS(exp, file = paste(outpath, "/", outname, ".RDS", sep = ""))
  
}
